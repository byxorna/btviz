<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="https://bootswatch.com/superhero/bootstrap.min.css">
    <style>
    body {
      margin: 0;
    }
    #container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    </style>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.2.3/backbone-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.77/Bacon.js"></script>
    <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/sigma.js/1.0.3/sigma.js"></script>-->
    <script src="public/sigma.min.js"></script>
    <script src="public/plugins/sigma.layout.forceAtlas2.min.js"></script>
  </head>
  <body>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <button type="button" class="forcetoggle btn btn-primary" data-toggle="button">
      Toggle Force Layout
    </button>
    <div id="container"></div>
    <script >
    // track state here...
    var swarm = {
      a:{ratio:2.0,peerlist:["b","d","f","g"]},
      b:{ratio:.5,peerlist:["c","d","e"]},
      c:{ratio:0.0,peerlist:[]},
      d:{ratio:0.1,peerlist:[]},
      e:{ratio:0.2,peerlist:["e","f","g","h"]},
      f:{ratio:0.4,peerlist:["a","b","c","g"]},
      g:{ratio:2.0,peerlist:[]},
      h:{ratio:1.0,peerlist:[]},
      i:{ratio:1.0,peerlist:["h"]},
    };
    var colorUnfocused = '#4e5d6c';
    var colorInitializing = '#4e5d6c';
    var colorSeeding = '#5bc0de';
    var colorComplete = '#5cb85c';
    var colors = ['#d9534f','#df691a','#f0ad4e','#5cb85c'];
    var colorscale = d3.scale.quantize().domain([0.0,1.0]).range(colors);

    var swarmGraph = {
      nodes: [],
      edges: [],
    };

    // takes the peer object, and an index in the swarm (int)
    function getGraphNode(id, peer, i, swarmsize){
      var color = colorscale(peer.ratio);
      if (peer.ratio > 1.0) {
        color = colorSeeding;
      }
      // we dont care about x,y because we will let the forceatlas2 take care of that
      return {
        id: id,
        label: id + ' ratio: ' + peer.ratio,
        x: Math.floor(Math.random()*100),
        y: Math.floor(Math.random()*100),
        size: 5,
        color: color,
      };
    }

    // given the new state of the swarm, update all the graph nodes as needed
    function updateGraph(sig, swarm){
      var swarmsize = _.size(swarm);
      _.each(sig.graph.nodes(),function(n, i){
        swarm[n.id].ratio += 0.1
        var newnode = getGraphNode(n.id,swarm[n.id],i,swarmsize);
        n.label = newnode.label;
        n.color = newnode.color;
      });
    }

    var i = 0;
    var n = _.size(swarm);
    _.each(swarm,function(peer, id){
      // arrange nodes in a circle. This wont scale very well though...
      swarmGraph.nodes.push(getGraphNode(id, peer,i,n));
      _.each(peer.peerlist,function(connPeer){
        swarmGraph.edges.push({
            id: id + '_' + connPeer,
            target: connPeer,
            source: id,
        });
      });
      i++;
    });

    console.log("nodes:",swarmGraph.nodes);
    console.log("edges:",swarmGraph.edges);

    // Let's first initialize sigma:
    var s = new sigma({
      graph: swarmGraph,
      container: 'container',
      settings: {
        drawEdges: true,
        edgeColor: 'default',
        defaultEdgeColor: colorInitializing,
      }
    });

    var forceConfig = {
      barnesHutOptimize: true,  //should we use the algorithm's Barnes-Hut to improve repulsion's scalability (O(nÂ²) to O(nlog(n)))? This is useful for large graph but harmful to small ones.
      worker: false,    // without this, my laptop becomes unusable when running... :(
      //iterationsPerRender: 10000,
    };

    $(document).ready(function(){
      // run sigma
      s.refresh();
      $('.forcetoggle').on('click',function(e){
        if (s.isForceAtlas2Running()){
          s.stopForceAtlas2();
        } else {
          s.startForceAtlas2(forceConfig);
        }
      });

      // https://github.com/jacomyal/sigma.js/tree/master/plugins/sigma.layout.forceAtlas2
      s.startForceAtlas2(forceConfig);

      // tick up ratios over time
      setInterval(function(){
        updateGraph(s, swarm);
        s.refresh();
      },1000);
    });

    /*
    s.bind('clickNode', function(e) {
//TODO neighbors needs to be implemented
      var nodeId = e.data.node.id,
          toKeep = s.graph.neighbors(nodeId);
      toKeep[nodeId] = e.data.node;

      s.graph.nodes().forEach(function(n) {
        if (toKeep[n.id])
          n.color = n.originalColor;
        else
          n.color = colorUnfocused;
      });

      s.graph.edges().forEach(function(e) {
        if (toKeep[e.source] && toKeep[e.target])
          e.color = e.originalColor;
        else
          e.color = colorUnfocused;
      });

      // Since the data has been modified, we need to
      // call the refresh method to make the colors
      // update effective.
      s.refresh();
    });
    */


    </script>
  </body>
</html>
